"""Sandboxed code execution for agent-generated code.

This module provides isolated execution environments for running
code generated by agents. Supports both local execution (for testing)
and Docker-based sandboxing (for production use).

Key components:
- SandboxExecutor: Abstract interface for code execution
- LocalExecutor: Direct local execution (no isolation)
- DockerExecutor: Docker container-based sandboxed execution
- ExecutionResult: Structured result from code execution

Usage:
    from examples.agent_system.sandbox import LocalExecutor, DockerExecutor

    # Local execution (for testing)
    executor = LocalExecutor(timeout_seconds=30)
    result = executor.execute("print('Hello')")

    # Docker execution (for production)
    executor = DockerExecutor(image="python:3.11-slim")
    result = executor.execute("print('Hello')")
"""

from __future__ import annotations

import subprocess
import sys
import tempfile
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from io import StringIO
from pathlib import Path
from typing import Any


class ExecutionStatus(Enum):
    """Status of code execution."""

    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


@dataclass
class ExecutionResult:
    """Result from code execution.

    Attributes:
        status: Execution status (success, error, timeout, cancelled)
        stdout: Standard output from the code
        stderr: Standard error from the code
        exit_code: Exit code (0 for success, non-zero for error)
        duration_ms: Execution duration in milliseconds
    """

    status: ExecutionStatus
    stdout: str
    stderr: str
    exit_code: int
    duration_ms: int | None = None

    def is_success(self) -> bool:
        """Check if execution was successful."""
        return self.status == ExecutionStatus.SUCCESS and self.exit_code == 0


class SandboxExecutor(ABC):
    """Abstract interface for code execution.

    Subclasses must implement the execute method to provide
    isolated code execution in their respective environments.
    """

    @abstractmethod
    def execute(self, code: str) -> ExecutionResult:
        """Execute code and return the result.

        Args:
            code: Python code to execute

        Returns:
            ExecutionResult with status, output, and metrics
        """
        pass


class LocalExecutor(SandboxExecutor):
    """Local code execution (no sandboxing).

    WARNING: This executor runs code directly on the local machine.
    Use only for testing or trusted code.

    Attributes:
        timeout_seconds: Maximum execution time before timeout
    """

    def __init__(self, timeout_seconds: int = 30) -> None:
        """Initialize the local executor.

        Args:
            timeout_seconds: Maximum execution time (default: 30s)
        """
        self.timeout_seconds = timeout_seconds

    def execute(self, code: str) -> ExecutionResult:
        """Execute code locally using subprocess.

        Args:
            code: Python code to execute

        Returns:
            ExecutionResult with captured output
        """
        start_time = time.time()

        try:
            # Write code to temporary file
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".py", delete=False
            ) as f:
                f.write(code)
                temp_path = f.name

            try:
                # Execute with subprocess
                result = subprocess.run(
                    [sys.executable, temp_path],
                    capture_output=True,
                    text=True,
                    timeout=self.timeout_seconds,
                )

                duration_ms = int((time.time() - start_time) * 1000)

                if result.returncode == 0:
                    return ExecutionResult(
                        status=ExecutionStatus.SUCCESS,
                        stdout=result.stdout,
                        stderr=result.stderr,
                        exit_code=0,
                        duration_ms=duration_ms,
                    )
                else:
                    return ExecutionResult(
                        status=ExecutionStatus.ERROR,
                        stdout=result.stdout,
                        stderr=result.stderr,
                        exit_code=result.returncode,
                        duration_ms=duration_ms,
                    )

            finally:
                # Clean up temp file
                Path(temp_path).unlink(missing_ok=True)

        except subprocess.TimeoutExpired:
            duration_ms = int((time.time() - start_time) * 1000)
            return ExecutionResult(
                status=ExecutionStatus.TIMEOUT,
                stdout="",
                stderr=f"Execution timed out after {self.timeout_seconds}s",
                exit_code=-1,
                duration_ms=duration_ms,
            )
        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return ExecutionResult(
                status=ExecutionStatus.ERROR,
                stdout="",
                stderr=str(e),
                exit_code=1,
                duration_ms=duration_ms,
            )


class DockerExecutor(SandboxExecutor):
    """Docker-based sandboxed code execution.

    Runs code inside a Docker container for isolation.
    Requires Docker to be installed and running.

    Attributes:
        image: Docker image to use (default: python:3.11-slim)
        timeout_seconds: Maximum execution time before timeout
        memory_limit: Memory limit for container (e.g., "256m")
        cpu_limit: CPU limit for container (e.g., "0.5")
    """

    def __init__(
        self,
        image: str = "python:3.11-slim",
        timeout_seconds: int = 30,
        memory_limit: str = "256m",
        cpu_limit: str = "0.5",
    ) -> None:
        """Initialize the Docker executor.

        Args:
            image: Docker image to use
            timeout_seconds: Maximum execution time
            memory_limit: Memory limit for container
            cpu_limit: CPU limit for container
        """
        self.image = image
        self.timeout_seconds = timeout_seconds
        self.memory_limit = memory_limit
        self.cpu_limit = cpu_limit

    def execute(self, code: str) -> ExecutionResult:
        """Execute code in a Docker container.

        Args:
            code: Python code to execute

        Returns:
            ExecutionResult with captured output
        """
        start_time = time.time()

        # Build docker command
        docker_cmd = [
            "docker",
            "run",
            "--rm",  # Remove container after execution
            "--network=none",  # No network access
            f"--memory={self.memory_limit}",
            f"--cpus={self.cpu_limit}",
            self.image,
            "python",
            "-c",
            code,
        ]

        try:
            result = subprocess.run(
                docker_cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout_seconds,
            )

            duration_ms = int((time.time() - start_time) * 1000)

            if result.returncode == 0:
                return ExecutionResult(
                    status=ExecutionStatus.SUCCESS,
                    stdout=result.stdout,
                    stderr=result.stderr,
                    exit_code=0,
                    duration_ms=duration_ms,
                )
            else:
                return ExecutionResult(
                    status=ExecutionStatus.ERROR,
                    stdout=result.stdout,
                    stderr=result.stderr,
                    exit_code=result.returncode,
                    duration_ms=duration_ms,
                )

        except subprocess.TimeoutExpired:
            duration_ms = int((time.time() - start_time) * 1000)
            return ExecutionResult(
                status=ExecutionStatus.TIMEOUT,
                stdout="",
                stderr=f"Docker execution timed out after {self.timeout_seconds}s",
                exit_code=-1,
                duration_ms=duration_ms,
            )
        except FileNotFoundError:
            duration_ms = int((time.time() - start_time) * 1000)
            return ExecutionResult(
                status=ExecutionStatus.ERROR,
                stdout="",
                stderr="Docker is not installed or not in PATH",
                exit_code=1,
                duration_ms=duration_ms,
            )
        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return ExecutionResult(
                status=ExecutionStatus.ERROR,
                stdout="",
                stderr=str(e),
                exit_code=1,
                duration_ms=duration_ms,
            )


def get_executor(use_docker: bool = False, **kwargs: Any) -> SandboxExecutor:
    """Factory function to get an executor.

    Args:
        use_docker: Whether to use Docker (default: False for local)
        **kwargs: Additional arguments for the executor

    Returns:
        SandboxExecutor instance
    """
    if use_docker:
        return DockerExecutor(**kwargs)
    return LocalExecutor(**kwargs)
